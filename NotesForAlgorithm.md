# ch2 C/C++快速入门

## 2.1 基本数据类型

1. int（4字节）：绝对值在10^9范围以内的整数 -2^31~(2^31-1)

2. long long（8字节）：取值范围超过2147483647（如10^10或10^18） -2^63~(2^63-1)

​       long long类型赋初值大于2^31-1时需要在初值后加上LL，否则编译会出错

​       long long 的输入输出：%lld

3. 整形数据可以加unsigned表示无符号类型占用位数和原先相同，但把负数范围挪到正数部分：

​       **不需要符号位了所以最高位也可以用来表示数据**：

​       unsigned int：0~2^32-1 

​       unsigned long long：0~2^64-1

4. float（4字节）：有效精度6~7位 -2^128~2^128
5. double （8字节）：有效精度15~16位 -2^1024~2^1024

​       输入时用%lf，输出时用%f，%.nf表示保留n位小数

​       **浮点型全用double存储即可**

6. char：小写字母比大写字母的ASCII码值大32

​       C只能用字符串数组实现字符串，但C++里有string类型

7. 宏定义：`#define pi 3.14`

​        `#define 标识符 任何语句或片段` 

​       `#define ADD(a,b) ((a)+(b)) //用ADD(a,b)代替a+b的功能，必须加括号`

​       `const double pi = 3.14`

## 2.2 、2.3顺序结构、选择结构

1. 数学函数

```c
#include <cmath>
fabs(a)：a 的绝对值
floor(a)：a 的向下取整
ceil(a)：a 的向上取整
round(a)：a 的四舍五入（需要注意 %.0f 使用的是四舍六入五成双规则，与 round 函数不同）
pow(a, b)：a 的 b 次方，其中 b 也可以是浮点型
sqrt(a)：a 的算术平方根（即开根号）
log(a)：a 的以自然对数e为底的对数
```

2. scanf函数的使用

```c
scanf("格式控制", 变量地址); 
//输入时需要按空格，就写成%d %d或者干脆不加空格；输入时需要按冒号，就写%d:%d；输入时需要按逗号，就写%d,%d这就是格式控制

int a;
char c, str[10];
scanf("%d %c%s",&a,&c,str);
//%c格式可以读入空格和换行，所以可以多加一个空格的格式来卡掉一个空格
```

3. Switch结构

```c
int a = 6,b = 2;
    switch(a + b)
    {
        case 2:
            printf("%d\n",a);
            break;
        case 3:
            printf("%d\n",b);
            break; //没有break就会一个一个往下执行
        case 4:
            printf("%d\n",a+b);
            break;
        default: //都不符合的情况，最后跳出分支
            printf("sad story\n");
    }
```

## 2.4、2.5 循环、数组

1.  **BubbleSort**

```c
#include <stdio.h>
int main() {
    int a[10] = {3,1,4,5,2},i,j;
    for(i = 1;i<=4;i++)
    {
        for(j = 0;j<5-i;j++)
        {
            if(a[j]>a[j+1])
            {
                int temp = a[j];
                a[j] = a[j+1];
                a[j+1] = temp;
            }
        }
    }
    for(i = 0;i<5;i++)
    {
        printf("%d ",a[i]);
    }
    return 0;
}
/*i从1开始递增，j从0开始递增到5-i，
 这样i的每一趟循环都可以排除掉已经排好序的部分，使需要对比操作的序列尽量短
 用i计数的原因是每一趟会确定一个元素的排序，则待排序序列的长度会-i*/


//输入数组也需要取地址
scanf("%d", &a[i]);
```

2. memset：对数组中每一个元素赋相同值

```c
memset(数组名, 值, sizeof(数组名));
//需要#include <string.h>
//建议只赋值0或-1，因为按字节赋值，如int型的4个字节会被设置成相同值，0的补码全为0，-1的补码全为1
//如果赋值其他数字，用fill函数
/*由于 1 个 int 型变量占用 4 个字节，对每个字节都赋值 1 的时候，因 1 的二进制为 00000001，因此这 4 个字节的二进制拼起来后是 00000001000000010000000100000001，对应的十进制为 16843009，所以最终数组每个元素都是 16843009*/
```

3. getchar和putchar用来输入和输出单个字符，可以接收空格
4. gets、puts

gets输入一行字符串识别到\n作为结束，会直接将字符串存放于一维数组或二维数组中的一维

puts输出一行字符串，并紧跟换行

```c
#include <stdio.h>
int main() {
    char str1[20];
    char str2[5][10];
    int i;
    gets(str1);
    for(i = 0;i<3;i++)
    {
        gets(str2[i]);
    }
    puts(str1);
    for(i = 0;i<3;i++)
    {
        puts(str2[i]);
    }
    return 0;
}
```

### **gets/puts被淘汰，现在有更先进的输入字符串的方式：**

1. **`cin.getline`**：仅 `C++` 可用，`C语言` 不可用。需要添加 `#include <iostream>` 头文件，并且在头文件后增加一行 `using namespace std;`。然后我们可以像下面这样使用，其中第一个参数是字符数组，第二个参数是最大允许读入的字符个数，设置为字符数组的长度即可。这种做法和 `gets` 的效果完全相同。

   C++

   ```cpp
   cin.getline(str, MAX_LEN);
   ```

2. **`scanf("%[^\n]", str)`**：`C++` 和 `C语言` 均可用。原理是使用 `scanf` 的正则表达式输入功能，其中 `%[^\n]` 的含义是 「只要不为 `\n`，就一直读入」，也就是说它会读入到换行符结束，即实现了读入整行的效果（关于正则表达式的内容留给有兴趣的同学了解，这里就不展开了）。

   ```c
   scanf("%[^\n]", str);
   ```

   需要注意：

   - 这种方式是当碰到 `\n` 时停止输入，但不会干掉换行符，因此后面需要继续输入的部分场景有可能会被这个换行符干扰，例如当连续输入多行字符串的时候会有问题，需要自己动手干掉换行符（细节可以参考 [字符串输入输出II](https://sunnywhy.com/problem/32)）

     ```c
     // %*c表示输入一个字符，但不存储在变量中
     // 下面两种写法根据需要选用
     scanf("%[^\n]%*c", str);    // 在输入整行后吸收掉\n
     scanf("%*c%[^\n]", str);    // 先吸收上一行的\n，再输入整行
     ```

   - 如果是空行（例如不输入字符串直接按回车键）则会输入失败，即 `str` 不会被空字符串覆盖。因此如果可能有空行的场景，最好手动将 `str` 置为空行：

     ```c
     // 可能有空行时要这样写
     // scanf函数会返回成功输入的变量个数
     // 如果个数不为1，说明str输入失败，此时需要手动将str置为空
     if (scanf("%[^\n]", str) != 1) {
         str[0] = '\0';
     }
     ```

3. **`fgets`**：`C++` 和 `C语言` 均可用。用法如下所示，其中第一个参数是字符数组，第二个参数是最大允许读入的字符个数，设置为字符数组的长度即可，第三个参数是文件指针，对做算法题来说设置为 `stdin` 即可，表示标准输入流。

   ```c
   fgets(str, MAX_LEN, stdin);
   ```

   但是 `fgets` 函数有个特点，那就是它会把我们输入的这行最后面的换行符也读到字符数组里。例如我们输入一行字符串 `"aaa"` 然后按回车，此时存到数组里的结果就变成了 `"aaa\n\0"` 而不是 `"aaa\0"`），这就给我们做算法题带来一些麻烦（特别是要读入多行字符串的情况），因此在使用 `fgets` 函数输入后需要做额外处理，即把 `\n` 替换为 `\0`，如下所示：

   ```c
   fgets(str, MAX_LEN, stdin);
   str[strcspn(str, "\n")] = '\0';
   //str字符串里第一次出现\n的长度
   ```

   其中 `strcspn` 函数需要引入 `string.h` 头文件，含义是在一个数组中寻找指定字符（`strcspn(str, "\n")` 表示在 `str` 中寻找换行符），并返回第一个满足的下标。注意不能用 `str[strlen(str) - 1] = '\0'` 的方式来实现，因为有可能这行已经是最后一行，没有换行了，这时候字符数组末尾不会有多余的 `\n`，此时执行 `str[strlen(str) - 1] = '\0'` 会覆盖错位置。

   另外需要注意，由于 `fgets` 需要额外存储 `\n\0` 两个字符，所以字符数组的大小需要至少比题目规定的多 （而不是多 ），这在一些多行输入的场景里需要考虑到。

5. 空字符串\0，即NULL，ASCII码为0，用gets或scanf输入字符串时会自动在字符串结尾添加\0并占用一个字符位（也就是说字符串的实际长度会比输入的长度多1），只有字符串数组需要，\0不是空格，空格的ASCII码是32
6. 不用%s或者gets输入字符串（比如getchar）时需要在输入的每个字符串后面加入\0，否则输出时末尾可能会因为无法识别而出现乱码

7. string.h头文件

```c
strlen(字符串数组); //得到字符串数组中第一个\0前的字符的个数
strcmp(字符数组1,字符数组2); //按字典顺序返回两个字符串大小比较的结果
strcpy(字符数组1,字符数组2); //把字符数组2复制给字符数组1，包括\0,数组1的值会被数组2的覆盖
strcat(字符数组1,字符数组2); //把字符数组2接到字符数组1的后面
strcspn(字符数组1,字符数组2); //从字符数组1的开头逐字符扫描，直到遇到第一个出现在字符数组2中的字符为止，返回此前的字符数量
strcspn(str, "\n");
//str字符串里第一次出现\n时的字符串长度
```

8. sscanf和sprintf

```c
sscanf(str, "%d", &n);
//把字符数组str中的内容以"%d"的格式写到n中,字符串应该是数字形式
sprintf(str, "%d", n);
//把n以“%d”的格式写到str字符数组中,如果n=233，则str[0]=2,str[1]=3,str[2]=3
```

## 2.7 指针

1. 变量的地址一般指它占用的字节中第一个字节的地址：int型变量的地址是它占用的4byte当中第一个字节的地址

2. 指针变量

```c
int *p1, *p2, *p3;
// 指针变量中存放地址
int a;
int *p = &a;
     p = &a;
// int*是变量类型，p是变量名，用来存储地址，因此地址要赋值给p
// 两种写法都行，&取地址运算符，把变量a的地址取出来赋值给指针变量p
// 如果需要取出p指针指向的变量的值，用*p
// 有关于指针变量自身的长度，我电脑测出来的都是8字节
```

3. 指针变量加减法：即地址偏移的距离

```c
int* p;
p+1;
// 意思是p所指向的int型变量的下一个int型变量地址
++p;
//指针变量支持自增、自减操作
```

### 2.7.3 指针与数组

`&a[0]` 表示数组元素的地址，数组名称也作为数组的首地址使用，有  `a == &a[0]`这两个完全等价

由于指针变量可以做加减法，那么`a +i` 等同于`&a[i]`，指的是数组a的首地址偏移i个int型变量的位置，但`a +i`是一个地址，要访问`a[i]`中的元素需要`*(a + i)`

一种输入数组元素的新方法：

```c
scanf("%d",a + i);
// 向a[i]中输入一个整数
printf("%d",*(a + i));
// 输出a[i]中的值
```

```c
int a[10] = {1,4,9,16,36,49};
int* p = a;
int* q = &a[5];
printf("q = %d\n", q);
printf("p = %d\n", p);
printf("q - p = %d\n", q-p);
// q-p=5，表示q和p之间差5个int元素，20byte，每个int型变量长度为4字节
```

### 2.7.4 指针变量做函数参数

```c
void change(int* p)
{
    *p = 233;
}
int main()
{
    int a;
    int* p = &a;
    a = 5;
    change(p);
    printf("a = %d\n",a);
    return 0;
}
//可以改变a的值
```

### 2.7.5 引用

1. 引用本质是给原变量取一个别名，不产生副本，对引用变量的操作就是对原变量的操作（并非取地址），常量不可以使用引用

```c
void change(int &x)
{
    x = 1;
}
int main() {
    int a = 10;
    change(a);
    printf("%d\n",a);
    return 0;
}
// 变量可以是任意名称，结果都是给被传入的变量取别名
```

2. 指针的引用

```c
void swap(int* &p1,int* &p2)
{
    int* tmp = p1;
    p1 = p2;
    p2 = tmp;
}
// 相当于给两个指针取了个别名，直接控制指针变量的指向，否则只能改变指针指向的空间的值，而不能改变指针指向
int main()
{
    int a=1,b=2;
    int* p1=&a;
    int* p2=&b;
    swap(p1,p2);
    printf("a=%d,b=%d\n",*p1,*p2);
    return 0;
}
```

## 2.8 结构体、结构体数组、结构体对齐

1. 结构体类型声明最后一定要加分号

2. 定义结构体变量时，必须使用`struct student`进行定义

3. 结构体初始化只能在一开始定义时进行:`struct student s = {1001,"lele",20,65,"shenzhen"};`如果s已经定义，则只能对它的每个成员单独赋值：`s.num = 1003;`
4. 结构体对齐三大法则：

自然对齐：每个成员的地址是其数据类型大小的整数倍（如int会被对齐到4字节边界）

填充字节：如果一个成员大小不成对齐边界的整数倍，编译器会添加填充字节以确保下一个成员能够正确对齐

结构体总大小：通常是其最大成员大小的整数倍，确保结构体数组的每个元素都按照相同的规则对其

eg：一个结构体元素最大的是double类型，则结构体的大小是8的整数倍（字节个数）

`sizeof(s1) //计算出s1包含多少个字节`

### 构造函数给结构体赋值只能在C++中使用，C语言还是老老实实写一个函数赋值

可以对结构体进行批量赋值的方法，前面的赋值方法只能一个结构体一个结构体赋值：

```c
#include <stdio.h>
struct Point
{
    int x,y;
    Point(){};
    //默认生成的构造函数，函数名与结构体类型名相同，没有返回类型，这个函数使得用户可以直接定义Point类型的变量而不进行初始化
    Point(int _x, int _y): x(_x), y(_y) {}
    //手动提供指定变量的初始化参数，_x、_y可以是任何变量名，只要不和已有变量冲突
    Point(int _x, int _y)
    {
        x = _x;
        y = _y;
    }
    //这个和上一条代码效果相同
    //构造体函数可以有多个同名，只要参数不同即可
}pt[10];
int main() {
    int num = 0;
    for(int i = 1;i<=3;i++)
    {
        for(int j = 1;j<=3;j++)
        {
            pt[num++] = Point(i,j);
        }
    }
    for(int i = 0;i<num;i++)
    {
        printf("%d,%d\n",pt[i].x,pt[i].y);
    }
    return 0;
}
```

### 结构体指针和typedef

1. 一个结构体变量的指针就是该变量所占据的内存段的起始地址，结构体指针可以访问结构体内的每个成员
2. 结构体指针可以指向结构体数组，其中保存的是结构体数组的首地址：

```c
struct student sarr[3] = {1001,"lilei",'M',1005,"zhangsan",'M',1007,"lili",'F'};
//给结构体数组初始化赋值
struct student *p;
p = &sarr;
printf("%d %s %c\n",p->num,p->name,p->sex);
```

结构体指针可以自+1来指向数组的下一个元素：

`p = p+1;` 偏移量为一个该类型的大小

3. 给结构体指针申请空间并赋值：

```c
p = (struct student*)malloc(sizeof(struct student));
//申请一块结构体大小的空间，malloc会返回int类型，所以要强制转换成结构体指针类型
p->num = 1006;
p->sex = 'M';
strcpy(p->name,"longge");
//p->name = "longge";字符串不能直接赋值，需要用库函数strcpy()
```

4. 结构体指针p的大小仍然是一个int类型指针的大小，但它之前申请的空间的大小为结构体的大小：

![](D:\Documents\code\C&C++Learning\WDCLanguage\imgs\屏幕截图 2026-01-04 170611.png)

5. typedef可以用来简化结构体名称（取别名）

```c
typedef struct student{
    int num;
    char name[20];
    char sex;
}stu,*pstu;
//stu等价于struct student，pstu等价于struct student*
//stu s = {1001,"wangle",'M'};
//pstu p;等价于stu *p; 定义一个结构体指针变量
//p = &s;

typedef int INTEGER;
//一个整形的别名
```

## 2.9 补充

### 2.9.1 cin、cout

1. cout控制double型的精度：

```c
#include <iomanip>
cour<< setiosflags(ios::fixed)<< setprecision(2)<<123.4567<<endl;
//输出123.46
//具体原理后面需要再了解
```

2. π的值：`const double Pi = acos(-1.0);`


### 好烦2.9计算误差相关的东西后面再查漏补缺

## 2.10 黑盒测试

1. 单点测试：系统判断每组数据输出结果是否正确，从编程角度来说单点测试只需要按正常的逻辑执行一遍程序即可，也就是程序只需要能够完整执行一组数据

2. 多点测试：要求程序可以一次性执行所有数据（大部分在线评测系统都是这种模式）

3. 多点测试的三种输入方式：

   ```c
   //while...EOF型 没有给出输入结束条件，默认读到文件末尾
   while(scanf("%d",&n) != EOF){...}
   //EOF表示-1，文件到达结尾无法读入时，scanf应该返回-1
   //命令提示符中无法出发EOF状态，可以通过ctrl+c主动触发
   
   //scanf()和gets()有两种方式：
   while(scanf("%s",str) != EOF){...}
   while(gets(str) != NULL){...} 
   ```

   ```c
   //while...break型 题目要求当输入的聚聚满足某个条件时停止输入
   //如表示“a、b中有一个不为零时进行循环”
   while(scanf("%d%d",&a,&b),a||b){...}
   ```

   ```c
   //while(T--)型 题目给出测试数据的数组，然后给出相应数量组数而输入数据
   while(T--){...}
   ```


# ch3 入门篇1 入门模拟

## 3.1 简单模拟（记录上机训练实战指南里的错题）

### B1032

```c
#include <stdio.h>
const int maxn = 100010;
int school[maxn] = {0};
//长度可变的数组应在cpp文件中使用，c不给过
int main() {
    int n, schId, score;
    scanf("%d",&n);
    for(int i = 0;i<n;i++)
    {
        scanf("%d%d",&schId,&score);
        school[schId]+=score;
    }
    int k = 1, MAX = -1;
    //反正分数都是大于等于0的，初始最大值是-1即可
    for(int i = 1;i<=n;i++)
    {
        if(school[i]>MAX)
        {
            MAX = school[i];
            k = i;
        }
    }
    printf("%d %d\n",k,MAX);
    return 0;
}

```

